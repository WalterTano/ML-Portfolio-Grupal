{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/austin-animal-center/","result":{"data":{"datoCmsBlogpost":{"id":"DatoCmsBlogpost-192169090","slug":"austin-animal-center","title":"Caso de Estudio: Austin Animal Center","excerpt":"Se realiza un caso de estudio utilizando los conjuntos de datos del Austin Animal Center para generar un modelo de aprendizaje automático capaz de predecir si un animal será adoptado o no, al momento de su ingreso al refugio.","date":"2023-10-17","html":"### Contenido\n\n- [Introducción](#introduccion)\n- [Cargando y visualizando los datos](#cargando-y-visualizando-los-datos)\n- [Tratamiento previo de los datos](#tratamiento-previo-de-los-datos)\n- [Entrenando modelos](#entrenando-modelos)\n- [Ajuste con Feature Selection](#ajuste-con-feature-selection)\n- [Conclusión](#conclusion)\n\n### Introducción\n\nEn este artículo, se realizará un caso de estudio utilizando los conjuntos de datos *\"Austin Animal Center Intakes\"* y *\"Austin Animal Center Outcomes\"* (disponibles en [Kaggle](https://www.kaggle.com/datasets/aaronschlegel/austin-animal-center-shelter-intakes-and-outcomes)). Se describirá el uso de diversas herramientas de RapidMiner para el análisis, el procesado y la visualización de los datos. Finalmente, generaremos un modelo de aprendizaje automático capaz de predecir si un animal será adoptado o no, basándose únicamente en los datos conocidos de éste durante su entrada al refugio.\n\n### Cargando y visualizando los datos\n\nPara este caso, la información de los animales del refugio existe en dos hojas de cálculo separadas. Una, contiene la información de los animales al momento de su entrada, mientras que la otra contiene la información al momento de su salida, si el animal ha dejado el refugio.\n\n#### Intakes (Entradas al refugio)\n\n![Intakes](https://www.datocms-assets.com/106983/1697499851-austin-animal-shelter-1.png)\n\n##### Atributos\n- **animal_id**: Identificador único del animal en el registro del refugio. Tipo *String*\n- **name**: Nombre del animal. Tipo *String*\n- **datetime**: Fecha y hora en que se creó el registro del animal. Tipo *String*\n- **monthyear**: Atributo duplicado de **datetime**. Tipo *String*\n- **found_location**: Ubicación donde fue encontrado el animal. Tipo *String*\n- **intake_type**: Tipo de entrada al refugio. Tipo *Categórico*\n    - Valores: *\"Public Assist\", \"Owner Surrender\", \"Stray\", \"Euthanasia Request\", \"Wildlife\"*.\n- **intake_condition**: Condición en la que el animal entró al refugio. Tipo *Categórico*\n    - Valores: *\"Normal\", \"Injured\", \"Aged\", \"Sick\", \"Feral\", \"Nursing\", \"Pregnant\", \"Other\"*\n- **animal_type**: Indica qué animal ingresó. Tipo *Categórico*\n    - Valores: *\"Dog\", \"Cat\", \"Other\", \"Bird\", \"Livestock\"*\n- **sex_upon_intake**: Indica el género del animal y si estaba castrado o no cuando ingresó al refugio. Tipo *Categórico*¨\n    - Valores: *\"Neutered Male\", \"Spayed Female\", \"Intact Male\", \"Intact Female\", \"Unknown\", \"NULL\"*\n- **age_upon_intake**: Indica la edad del animal cuando ingresó al refugio. Tipo *Categórico*\n    - Valores incluyen distintos valores para la edad del animal desde días hasta años.\n- **breed**: La raza del animal. Tipo *String*\n- **color**: El color o patrón de colores del animal. Tipo *String*\n\n#### Outcomes (Salidas del refugio)\n\n![Outcomes](https://www.datocms-assets.com/106983/1697499965-austin-animal-shelter-2.png)\n\n##### Atributos\n- **animal_id**: Identificador único del animal en el registro del refugio. Tipo *String*\n- **name**: Nombre del animal. Tipo *String*\n- **datetime**: Fecha y hora en que se creó el registro del animal. Tipo *String*\n- **monthyear**: Atributo duplicado de **datetime**. Tipo *String*\n- **date_of_birth**: Fecha de nacimiento estimada del animal. Tipo *String*\n- **outcome_type**: Tipo de salida del refugio. Tipo *Categórico*\n    - Valores: *\"Adoption\", \"Return to Owner\", \"Transfer\", \"Euthanasia\", \"Died\", \"Disposal\", \"Missing\", \"Rto-Adopt\", \"Relocate\"*.\n- **outcome_subtype**: Subtipo de salida del refugio. Tipo *Categórico*\n    - Valores: *\"Partner\", \"Foster\", \"Suffering\", \"SCRP\", \"Aggresive\", \"Rabies Risk\", \"Offsite\", \"Behavior\", \"Medical\", \"In Kennel\", \"In Foster\", \"Court/Investigation\", \"Enroute\", \"In Surgery\", \"At Vet\", \"Possible Theft\"*\n- **animal_type**: Indica qué animal ingresó. Tipo *Categórico*\n    - Valores: *\"Dog\", \"Cat\", \"Other\", \"Bird\", \"Livestock\"*\n- **sex_upon_outcome**: Indica el género del animal y si estaba castrado o no cuando salió del refugio. Tipo *Categórico*¨\n    - Valores: *\"Neutered Male\", \"Spayed Female\", \"Intact Male\", \"Intact Female\", \"Unknown\", \"NULL\"*\n- **age_upon_outcome**: Indica la edad del animal cuando salió del refugio. Tipo *Categórico*\n    - Valores incluyen distintos valores para la edad del animal desde días hasta años.\n- **breed**: La raza del animal. Tipo *String*\n- **color**: El color o patrón de colores del animal. Tipo *String*\n\n#### Entendiendo el problema\n\nUtilizando los conjuntos de datos anteriormente descritos, se solicita la construcción de un modelo de aprendizaje automático capaz de predecir si un animal será adoptado o no al momento de su ingreso al refugio. \n\nSabiendo esto, antes que nada, necesitaremos crear un conjunto de datos integrado, es decir, que combine los dos conjuntos disponibles. Esto es porque necesitamos un conjunto de datos que incluya tanto los datos de entrada como de salida de los animales para poder entrenar nuestro modelo. Más precisamente, necesitamos conocer si el tipo de salida fue una adopción o no.\n\n#### Integrando los conjuntos\n\nPara combinar estos conjuntos, podemos utilizar una herramienta poderosa que incluye RapidMiner, llamada *Turbo Prep*. Turbo Prep nos permite realizar operaciones de tratamiento de datos sobre nuestra información de una forma sencilla. Además, nos permite agregar estas operaciones como subprocesos para nuestro proceso de generación de modelos de Machine Learning, lo cual será muy conveniente.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697502027-austin-animal-shelter-3.png)\n\nImportando ambos conjuntos a Turbo Prep y utilizando la operación *Merge*, podemos combinar ambos conjuntos y generar un tercer conjunto resultante con su unión. La herramienta nos permite especificar qué tipo de unión (en este caso *Left Join*, para incluir una fila por cada registro de una entrada), si combinar o no las columnas repetidas (lo marcamos para eliminarlas) y los atributos a utilizar para identificar filas correspondientes entre los conjuntos (en este caso *animal_id* en ambos conjuntos).\n\nEl conjunto resultante incluirá la combinación de ambos conjuntos de datos. Es importante recordar que no todos los animales tienen un registro en el conjunto de *Outcomes*, por lo que deberemos separar estos conjuntos nuevamente en nuestro proceso o eliminar los registros duplicados.\n\nAhora tenemos un conjunto de datos válido para empezar a entrenar nuestro modelo. Sin embargo, antes de salir de Turbo Prep, realizaremos otras operaciones de tratamiento de los datos.\n\n### Tratamiento previo de los datos\n\n#### Selección de atributos\n\nEste conjunto incluye algunos atributos que podrían llegar a ser irrelevantes a la hora de considerar si adoptar o no a un animal.\n\nPor ejemplo, el nombre del animal al llegar al refugio (representado en el atributo *name*), ya que éste podría ser cambiado cuando se adopta. Otro atributo que también puede ser irrelevante es *found_location*, ya que, en la mayoría de los casos, es de poca importancia el lugar donde el animal fue encontrado para la decisión de su adopción.\n\nTambién existen atributos restantes de la unión de los conjuntos de datos que no usaremos para nuestro modelo, estos son: *sex_upon_outcome*, *age_upon_outcome* y *date_of_birth*.\n\nFinalmente, eliminaremos el atributo *monthyear*, ya que simplemente es un duplicado de *datetime*.\n\nPodemos remover todos estos atributos utilizando la operación *Transform* y la suboperación *Remove* de Turbo Prep.\n\n#### Derivando atributos\n\n##### Variable objetivo (*adopted*)\n\nPrestando atención al modelo actual y tomando en cuenta el objetivo del problema, se vuelve aparente que no tenemos una variable objetivo clara. En un principio, nuestra variable objetivo parecería ser *outcome_type*, sin embargo, los registros para esta variable incluyen muchos valores que no deseamos predecir. Siendo que únicamente queremos predecir si el animal fue adoptado o no, sería conveniente utilizar los valores presentes en este atributo y *outcome_subtype* para generar un atributo derivado que indique simplemente si el animal fue adoptado o no.\n\nPara esto, crearemos un atributo binario llamado *adopted* utilizando la operación *Generate* de Turbo Prep. Para esto, es necesario especificar una formula a utilizar para calcular los valores de este atributo. Utilizaremos la siguiente formula:\n\n```\n[outcome_type] == \"Adoption\" && [outcome_subtype] != \"Foster\"\n```\n\nVerificamos que el valor de *outcome_type* sea *\"Adoption\"*, pero además verificamos que *outcome_subtype* no sea igual a *\"Foster\"*. Esto es porque estamos asumiendo que este valor significa que el animal fue adoptado por otro refugio de animales, por lo que no lo contaremos como una adopción tradicional.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697503241-austin-animal-shelter-4.png)\n\nCon este atributo generado, podemos eliminar los atributos *outcome_type* y *outcome_subtype*, ya que no serán necesarios.\n\n##### Sexo y Estado de Castración (*sex* y *neutered*)\n\nObservando al atributo *sex_upon_intake*, podemos ver que proporciona dos piezas de información sobre el animal: su sexo (macho o hembra) y si está castrado o no. Sería conveniente separar esta información en dos atributos diferentes, para identificar la influencia de cada uno de estos por separado en el problema.\n\nEn este caso, podemos generar los dos atributos resultantes aprovechando la suboperación *Split* de la operación *Transform* de Turbo Prep. Esta suboperación creará dos atributos a partir de la separación de los valores de un atributo por una cadena especificada. Para separar este atributo, bastará con que nuestra cadena sea un espacio.\n\nUna vez separados, será conveniente renombrar los atributos para poder identificar sus significados con facilidad. Esto es posible con la suboperación *Rename* de la operación *Transform*. Renombraremos los atributos a *sex* y *neutered*.\n\nFinalmente, será necesario realizar una transformación de los valores del atributo *neutered*, ya que este debería ser un binario que indica si el animal fue castrado o no. Para esto, utilizaremos la suboperación *Replace*, reemplazando *\"Neutered\"* y *\"Spayed\"* por 1 e *\"Intact\"* por 0.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697504180-austin-animal-shelter-5.png)\n\n##### Edad al llegar (age_upon_intake)\n\nEste atributo podría llegar a ser problemático, ya que representa un valor numérico, pero está presente como categórico en el conjunto de datos. Para el alcance de este caso de estudio, no lo modificaremos. Sin embargo, podrían realizarse distintas conversiones a este atributo para observar resultados diferentes. Por ejemplo, podrían agruparse los animales por distintos grupos etarios, o podrían juntarse a todos los animales que tienen menos de un año y asignar el valor \"0 years\".\n\n#### Corrigiendo tipos de atributos\n\nAl observar los atributos *datetime* en la descripción de atributos de los conjuntos de datos, podemos ver que inicialmente son interpretados como texto. Por esto, será necesario convertirlos a un tipo más adecuado para realizar cálculos en base a su valor.\n\nPodemos realizar este cambio con la suboperación *Change Type* de la operación *Transform*. Seleccionamos la opción *\"Change to date\"*, el tipo *\"date and time\"* e ingresamos el siguiente formato de fecha: *\"yyyy-MM-dd'T'HH:mm:ss\"*. Después de aplicar estos cambios, todos los valores del atributo deberían ser convertidos al tipo *date and time*, que representa más adecuadamente sus valores.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697506694-austin-animal-shelter-7.png)\n\n#### Lidiando con valores nulos\n\nSi prestamos atención a la definición de las categorías de algunos atributos, pudimos haber identificado que el atributo *sex_upon_intake* tenía algunos valores desconocidos y cuasi-nulos (*\"NULL\"*). Primero, convertiremos todos los valores desconocidos o cuasi-nulos a valores faltantes, para poder manejarlos todos de una vez.\n\nPara conseguir esto, utilizaremos nuevamente la suboperación *Replace* sobre el atributo derivado *neutered*, para convertir los valores *\"Unknown\"* y *\"NULL*\" a nulos.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697504606-austin-animal-shelter-6.png)\n\nAhora, como podemos observar en Turbo Prep, los atributos *sex* y *neutered* tienen valores faltantes. Ya que la cantidad de filas con valores faltantes es tan solo un 3.15% y tenemos más que suficientes datos como para poder entrenar un modelo, vamos a descartar las filas con valores faltantes. En este caso, imputar valores no es una opción válida, ya que no es posible generar valores que no causen un sesgo en nuestros resultados, y adivinar el sexo o el estado de castración de los animales no es factible.\n\nPara eliminar las filas faltantes, podemos utilizar el bloque *Filter Examples* con un comparador de *is missing* en cualquiera de los atributos mencionados anteriormente. \n\n*Recordemos que estos atributos se derivaron del mismo, por lo que cualquier registro que tiene un valor faltante en uno, también lo tiene en el otro.*\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697507099-austin-animal-shelter-8.png)\n\n#### Definiendo Label e Id en RapidMiner\n\nHasta ahora, RapidMiner no es capaz de identificar una variable objetivo o una variable identificadora en nuestro conjunto de datos. Podemos arreglar esto utilizando un bloque *Set Role* y asignándoles estos roles a las variables *adopted* y *animal_id*. Asignarle el rol de Id a esta última nos ayudará para eliminar registros duplicados.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697507147-austin-animal-shelter-9.png)\n\n#### Eliminando duplicados\n\nCon un atributo identificador, podemos aprovechar el bloque *Remove Duplicates* de RapidMiner para eliminar todas las filas donde se repita el atributo *animal_id*.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697507400-austin-animal-shelter-10.png)\n\n#### Resultado\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697507440-austin-animal-shelter-11.png)\n\nPodemos observar que el resultado de este proceso nos deja con un conjunto de datos para entrenamiento relativamente conciso, el cual probaremos con algunos algoritmos de aprendizaje automático.\n\n### Entrenando modelos\n\nProbaremos nuestro conjunto de datos con dos modelos disponibles en RapidMiner. Para cada uno, ejecutaremos un bloque de *Cross Validation* de RapidMiner con 10 pliegues, obteniendo así una evaluación bastante confiable de su rendimiento. Para todos utilizaremos la misma semilla local 1992, para evitar resultados cambiantes debido a la generación de semillas mejores o peores.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697508810-austin-animal-shelter-12.png)\n\n#### Naive Bayes\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697508936-austin-animal-shelter-13.png)\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697509051-austin-animal-shelter-16.png)\n\nPodemos ver una precisión del 68.63%, con un margen de error de 1,65%. No es un rendimiento ideal, pero es considerablemente mejor que adivinar (suponiendo que lanzamos una moneda para decidir si será adoptado o no el animal, las probabilidades de acertar serían 50%). Podríamos mejorar estos resultados si los atributos de nuestro conjunto de datos tuvieran distribuciones Gaussianas o cuasi-Gaussianas. Sin embargo, con los datos disponibles, esto no es posible. \n\nPodríamos interpretar esto como una señal de que Naive Bayes no es demasiado adecuado para este conjunto de datos.\n\n#### K-Nearest Neighbors (K-NN)\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697509426-austin-animal-shelter-14.png)\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697509452-austin-animal-shelter-15.png)\n\nEl rendimiento de K-NN fue un poco mejor que el de Naive Bayes, con una precisión del 70.77% y un margen de error de 1,18%. Se probaron distintos valores para K y se encontraron los mejores resultados con K = 12, aunque el rango de los resultados no varió más que 3%.\n\n### Ajuste con Feature Selection\n\nPara intentar obtener aún mejores resultados, podemos aplicar algoritmos de elección de atributos para obtener el conjunto más óptimo de columnas para usar en el entrenamiento de nuestros modelos.\n\n#### Forward Selection\n\nUtilizando el algoritmo de Forward Selection, que selecciona atributos al entrenar al modelo con cada uno de ellos, seleccionando el mejor y continuando con este proceso hasta no encontrar mejora, esperaríamos ver una reducción considerable en la cantidad de atributos finales.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697509747-austin-animal-shelter-17.png)\n\n##### Naive Bayes\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510081-austin-animal-shelter-18.png)\n\nEn Naive Bayes, podemos observar una mejora de casi el 5% en el rendimiento y una reducción del margen de error considerable.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510365-austin-animal-shelter-20.png)\n\nPodemos ver que este algoritmo de selección concluye que el único atributo relevante es la edad del animal al entrar al refugio. Si bien este atributo es intuitivamente importante a la hora de decidir si adoptar o no a un animal, dificilmente es el único de importancia en el conjunto.\n\n##### K-Nearest Neighbors (K-NN)\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510087-austin-animal-shelter-19.png)\n\nEn K-NN, hay una mejora de rendimiento, al igual que en Naive Bayes, pero esta es considerablemente menor, dejando a K-NN por detrás en términos de precisión. En este caso, el margen de error es casi nulo.\n\nUn detalle interesante, es que esta versión del modelo nunca predice que los animales vayan a ser adoptados. Es posible que la precisión de este modelo se deba a un sesgo en el conjunto de datos.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510371-austin-animal-shelter-21.png)\n\nEn este caso, el atributo seleccionado es la forma en que el animal llega al refugio. Intuitivamente, podemos deducir que este atributo no es realmente tan importante durante la decisión de adopción.\n\n#### Backward Elimination\n\nEste algoritmo, que consiste en la utilización de todos los atributos y la eliminación uno a la vez para encontrar el mejor conjunto, debería resultar en modelos que consideran más atributos que en el caso de Forward Selection.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510767-austin-animal-shelter-22.png)\n\n##### Naive Bayes\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510756-austin-animal-shelter-23.png)\n\nPodemos observar mejoras de rendimiento en comparación con la selección original, pero un peor rendimiento al comparar este modelo con el generado por Forward Selection.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510854-austin-animal-shelter-25.png)\n\nEn este caso, el conjunto de atributos seleccionados es intuitivamente razonable, ya que el tipo de animal, su sexo y su edad serían los factores principales a considerar antes de adoptarlo.\n\n##### K-Nearest Neighbors (K-NN)\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510761-austin-animal-shelter-24.png)\n\nPara K-NN también vemos una mejora en comparación al conjunto de atributos original, pero el rendimiento sigue estando levemente por debajo del conjunto de atributos producido por Forward Selection. Como mejora conceptual, podemos ver que esta variante del modelo sí predice que algunos animales serán adoptados, lo cual resulta en un aumento enorme en la precisión para esa clase (aunque se mantenga por debajo del 50%).\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697510849-austin-animal-shelter-26.png)\n\nAl igual que con Naive Bayes, el conjunto de atributos seleccionado tiene sentido intuitivamente, ya que todos son características que una persona tomaría en cuenta al decidir si adoptar un animal o no.\n\n#### Evolutionary Selection\n\nEste algoritmo, que selecciona atributos de forma evolutiva, debería producir un conjunto de atributos bastante próximo al óptimo.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697511271-austin-animal-shelter-27.png)\n\n##### Naive Bayes\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697512249-austin-animal-shelter-28.png)\n\nCuriosamente, para Naive Bayes, podemos ver que el resultado es exactamente igual al obtenido al usar Backwards Elimination, lo cual indica que éste ya había llegado a un conjunto de atributos óptimo.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697512234-austin-animal-shelter-29.png)\n\nEfectivamente, al revisar la lista de atributos, vemos que los seleccionados son los mismos que los que se seleccionaron en Backwards Elimination para Naive Bayes.\n\n##### K-Nearest Neighbors (K-NN)\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697512240-austin-animal-shelter-30.png)\n\nPara K-NN, este algoritmo fue el que dio mejores resultados, dando una mejora por sobre el conjunto original de atributos y los conjuntos producidos por los otros dos algoritmos de Feature Selection utilizados, con un 72,36% de precisión.\n\n![RapidMiner](https://www.datocms-assets.com/106983/1697512245-austin-animal-shelter-31.png)\n\nAl observar el conjunto de atributos elegidos, podemos ver que, en su mayoría, son atributos que intuitivamente resultan importantes a la hora de elegir una mascota para adoptar. \n\nAún se incluye el atributo *intake_type* en el conjunto, lo cual, teniendo en cuenta su inclusión recurrente entre los tres algoritmos de selección de atributos, probablemente indique algún punto de roce entre K-NN y el conjunto de datos; resultando en la relevancia de un atributo que intuitivamente debería ser relativamente irrelevante.\n\n### Conclusión\n\nAl probar dos algoritmos de aprendizaje automático no lineales sobre este conjunto de datos, encontramos que ambos resultaron tener un rendimiento relativamente parecido, incluso después de optimizar los atributos utilizados con algoritmos de Feature Selection.\n\nLos resultados obtenidos, si bien no fueron excepcionales, pueden considerarse exitósos a la hora de producir un modelo que tiene una precisión considerablemente mayor que el azar (casi 50% mejor). Sin embargo, es posible que mejores resultados sean posibles realizando más transformaciones a los datos y probando otros algoritmos de Machine Learning que puedan funcionar mejor con el conjunto y el problema.\n\nAlgunos algoritmos que me interesaría probar con este conjunto de datos en el futuro son Linear Discriminant Analysis (LDA) y Decision Tree (entre otros algoritmos basados en árboles).","isMarkdown":true,"image":{"url":"https://www.datocms-assets.com/106983/1697513275-animal-shelter.jpg?auto=format","gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://www.datocms-assets.com/106983/1697513275-animal-shelter.jpg?auto=format&w=1200","srcSet":"https://www.datocms-assets.com/106983/1697513275-animal-shelter.jpg?auto=format&dpr=0.25&w=1200 300w,\nhttps://www.datocms-assets.com/106983/1697513275-animal-shelter.jpg?auto=format&dpr=0.5&w=1200 600w,\nhttps://www.datocms-assets.com/106983/1697513275-animal-shelter.jpg?auto=format&w=1200 1200w","sizes":"(min-width: 1200px) 1200px, 100vw"}},"layout":"constrained","placeholder":{"fallback":"data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHBwgHBgoICAgLDw0NFRAQDg0NGBMVDg0NFxMZGBYVFhUaHysjGh0oHRUWJDUlKC0vMjIyGSI4PTcwPCsxMi8BCgsLDg0OHAoOFS8cFhw7Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL//AABEIABAAGAMBIgACEQEDEQH/xAAXAAADAQAAAAAAAAAAAAAAAAAABAUG/8QAHRAAAgIDAAMAAAAAAAAAAAAAAQMAAgQFEQYhIv/EABYBAQEBAAAAAAAAAAAAAAAAAAMEAv/EABcRAQEBAQAAAAAAAAAAAAAAAAIRAAH/2gAMAwEAAhEDEQA/AEde6tU/IjTc29V+gZZ1njywrpEYytOkVA5DfFdsdM0OjrNxukQmhGlpXEBAhKgVMKRu/9k="},"width":1200,"height":800},"alt":null}}},"pageContext":{"id":"DatoCmsBlogpost-192169090"}},"staticQueryHashes":["1987388502","3342712670"],"slicesMap":{"footer":"footer","header":"header"}}